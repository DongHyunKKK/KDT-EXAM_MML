# API(Application Programming Interface)
# - 창(윈도우) 생성 함수
# - 버튼 생성 함수

# 클래스
# - 구성 요소 : 메서드(함수) + 속성/필드 (변수)
# - 구성 요소 종류
#          - 클래스 변수 / 클래스 메서드 : 인스턴스 생성 없이 사용가능, cls
#          - 인스턴스 변수 / 인스턴스 메서드 : 반드시 인스턴스 생성 해야만 사용가능, self

# 객체/인스턴스
# 오버라이딩 => 반드시 상속 관계
# 오버로딩 => 함수 이름 동일 & 매개변수 다르게 생성
# 상속 => class

# 클래스 생성 (1) ---------------------------------------
# - 구성 요소 : 속성 + 메서드 => 모두 없는 클래스
# - 기본 상속 : Object ==> __속성명__, __메서드명__()
# ------------------------------------------------------
class A:
    pass

# 클래스 생성 (2) ---------------------------------------
# - 구성 요소 : 속성 + 메서드 => 인스턴스 변수와 메서드
# - 기본 상속 : Object ==> __속성명__, __메서드명__()
# ------------------------------------------------------
class B:
    # 인스턴스 객체 생성 및 속성 초기화 메서드
    def __init__(self, num, name):
        # self로 지정된 힙 메모리 주소에서 부터 속성 저장
        self.num = num
        self.name = name

    # 인스턴스 메서드
    def printInfo(self):
        print(f'num : {self.num}')
        print(f'name : {self.name}')

    # 연산자 맵핑 메서드 구현
    # 연산자 +와 맵핑된 메서드
    def __add__(self, other):
        print('__add__')
        return self.num + other.num

    # 연산자 -와 맵핑된 메서드
    def __sub__(self, other):
        print('__sub__')
        return self.num - other.num

# 클래스 생성 (3) ---------------------------------------
# - 구성 요소 : 속성 + 메서드 => 인스턴스 변수와 메서드, 클래스 변수
# - 기본 상속 : Object ==> __속성명__, __메서드명__()
# ------------------------------------------------------
class C:
    # 클래스 변수 => C 클래스로 생성된 모든 인스턴스에서 공유
    #            => 인스턴스 생성 없이 사용 가능
    loc = 'Daegu'
    
    # 인스턴스 객체 생성 및 속성 초기화 메서드
    def __init__(self, num, name):
        # self로 지정된 힙 메모리 주소에서 부터 속성 저장
        self.num = num
        self.name = name

    # 인스턴스 메서드
    def printInfo(self):
        print(f'num : {self.num}')
        print(f'name : {self.name}')

# 클래스 생성 (4) ---------------------------------------
# - 구성 요소 : 속성 + 메서드 => 클래스 변수와 메서드
# - 기본 상속 : Object ==> __속성명__, __메서드명__()
# ------------------------------------------------------
class DCalc:
    # 클래스 변수 => C 클래스로 생성된 모든 인스턴스에서 공유
    #            => 인스턴스 생성 없이 사용 가능
    name = 'CASIO'

    # 클래스 메서드
    @classmethod  # annotation 쓰지 않으면 클래스 메서드 실행 안된다.
    def addNum(cls, a, b):
        # print(cls.name)
        # print(cls.addNum(a, b))
        return  a + b
    
    @classmethod
    def minusNum(cls, a, b):
        return a - b
   
# 객체/인스턴스 생성 ------------------------------------
# => 생성 함수 : 클래스이름()
# => A()
# ------------------------------------------------------
a1 = A()
b1 = B(100, 'BB')
b2 = B(30, 'B2')
c1 = C(1000, 'CCC')

# 객체/인스턴스의 연산 -----------------------------------
print('ABC' + '123')
print([1, 2, 3] + [10, 20, 30])
print('========> ', b1 + b2)
print('========> ', b1 - b2)

# 객체/인스턴스의 속성/메서드 사용------------------------
# => 사용 방법 : 객체/인스턴스 변수명.속성
#                객체/인스턴스 변수명.메서드()
# ------------------------------------------------------
print('B 인스턴스 b1의 속성과 메서드 => ', b1.__dict__)  # 내것만 반환
print('B 인스턴스 b1의 속성과 메서드 => ', b1.__dir__()) # 내것과 부모것 모두 반환
print('B 클래스의 속성과 메서드 => ', B.__dict__)  # 클래스는 __dir__ 메서드 없다.

# 인스턴스 메서드 사용
c1.printInfo()

# 인스턴스 속성 사용
print(c1.name)

# 클래스 속성 사용
print('loc => ', C.loc, c1.loc)

# 인스턴스 메서드는 클래스명으로 사용 불가!! => self 즉 인스턴스 주소 및 정보 없음 
# C.printInfo()

# 클래스 속성 및 메서드 사용
print(f'DCalc.name : {DCalc.name}')
print(f'DCalc.addNum(10, 20) : {DCalc.addNum(10, 20)}')
print(f'DCalc.addNum(10, 20) : {DCalc.minusNum(10, 20)}')
